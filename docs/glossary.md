# Glossary

| Term | Definition |
|------|------------|
| **Dynamic Typing** | In a dynamically typed language, object types are determined at runtime.  This is in contrast to statically typed languages, where types are determined and enforced during the compilation phase.  The primary benefit of dynamic typing is the ease with which data structures can be created and modified.  Drawbacks include a lack of type information during development (rudimentary or no IntelliSense support) and lack of support for safe refactoring. |
| **Static Typing** | Statically typed languages infer or enforce types for values during compilation or interpretation.  This provides support for providing type information during development, detecting type/identifier mismatches during compilation and stronger refactor support.  However, this requires these type definitions to be created upfront and modified alongside the uses thereof as the program evolves.  Trades initial development speed for maintainability and clarity. |
| **Managed Memory** | Managed memory means that memory allocations and deallocations are handled by the runtime or interpreter that your application is running inside of.  Care should still be taken to avoid indefinitely hanging onto object references once they are no longer used, since this would prevent the Garbage Collector/Finalizer from deallocating this memory - leading to memory leaks. |
| **Unmanaged Memory** | In an unmanaged memory scenario your application is responsible for the initial allocation and subsequent clean-up of memory associated with variables.  Failure to properly deallocate memory used by objects that are no longer in scope will lead to memory leaks and (eventually) the inability of an application to continue executing. |
| **Scripting Language** | Scripting languages are traditionally processed by an interpreter at the time of execution, as opposed to being pre-compiled.  Certain scripting languages (such as Python and JavaScript) also support pre-compilation.  This compiles the application to a bytecode format which can be loaded much more efficiently by the runtime - alleviating the need for source code compilation during the load step. |
| **Compiled Language** | A compiled language has to be processed (compiled) by a compiler before it can be executed by the operating system or managed runtime.  Some managed languages also support the use of the compiler at runtime, allowing for the use of these languages as a scripting language.  A language is generally considered compiled if the runtime ingests pre-compiled byte code rather than raw source files. |
| **Imperative Programming** | Code is considered imperative if it provides step-by-step instructions for control flow and logic that the machine executes (mostly) in sequence as specified by the code.  Modern compilers include support for optimizing imperative code, but this support is much more limited than that of its declarative counterpart.  Examples include C#, Java and Python.  |
| **Declarative Programming** | Declarative code provides high-level instructions without specifying the exact control flow thereof.  This allows the compiler or interpreter to optimize the flow of the application for concurrency, performance and memory usage.  Examples include SQL, (Purely Functional) F# and Haskell. |
| **Object-Oriented Programming** | In Object-Oriented programming objects form the fundamental building blocks of the program.  Objects can be thought of as state with behaviour attached to it.  These objects are composed and manipulated imperatively to form the actual application.  Techniques such as inheritance, encapsulation, abstraction and polymorphism are often used in OO programming in order to improve the code quality and the ability to reason about the code's behaviour.  Examples include C#, Java and C++. |
| **Functional Programming** | As the name suggests, functions form the fundamental building blocks of functional code.  Functions are treated as first class citizens - allowing them to be stored as variables, passed in as parameters to other functions and returned as the result of a function call.  In FP state/data is separated from behaviour, allowing for greater flexibility and code reuse.  The composition of functions are done declaratively rather than imperatively.  FP languages often use the mature field of Category Theory as a basis for reasoning about composability and behaviour.  This provides a formal basis for logic around these aspects that can be exploited by the language and the associated libraries.  Examples include F#, Haskell and Scala. |
| **Procedural Programming** | Procedural programming relies on the sequence of procedure calls in order to control program flow.  These procedures consist of imperative code that support the standard imperative operations (looping, control flow, memory allocation, variable manipulation, etc.) as well as calls to other procedures.  Examples include C, Pascal and Go. |
| **Type Inference** | Type inference refers to the ability of a programming language to infer the data type of expressions at compile time.  This can take various forms, but generally relies on inspection of the declaration or usage of values/expressions.  This means that the types of variables or functions do not need to be specified explicitly in the code, but are instead inferred by the compiler.  In the case of C#, this is limited to support of the `var` type if the declaration and initial assignment of a variable is done together. E.g., `var x = 5;` would infer that the type of x is `int`, making it equivalent to `int x = 5;`.  Stronger type inference support allows for automatic parameterization, with the inference of constraints on these parameters.  E.g., in F# `let inline add a b = a + b` would lead to the parameterization of the values of `a` and `b`, with the inferred constraint that they both support the `+` operation.  Omitting the `inline` keyword would prevent parameterization, instead relying on the first usage of the `add` function in order to bind the types of `a` and `b`.  This sort of type inference is most commonly based on the [Hindley-Milner type system](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system).  |